from gm4_liquid_tanks:liquid_wrappers import Liquid
from functools import partial

potion_liquid = Liquid(capacity=300)
base_potion = potion_liquid.standard_unit('glass_bottle', 1, f_name="base_potion")
potion_liquid.standard_unit('glass_bottle', 3, f_name="long_potion") # register standard unit
long_potion = partial(potion_liquid.item_drain, output='glass_bottle', value=3) # long potions cannot be filled

from beet import JsonFile
effect_colors = JsonFile(source_path="gm4_potion_liquids/effect_colors.json").data

class_defs = {}

from csv import DictReader
with open("gm4_potion_liquids/potion_definitions.csv", "r") as csvfile:
    potion_def_reader = DictReader(csvfile)
    for row in potion_def_reader:
        if row["potion_id"] in ("awkward", "mundane", "thick", "water")+("weaving", "wind_charged", "oozing", "infested"):
            continue # skip this potion type for now # FIXME
            # FIXME reapply the new effect that dont have skins
        
        class_key = (row["effect_id"], row["effect_amplifier"])
        # setup new liquid type if necessary and add to the dict
        if class_key not in class_defs:
            # @potion_liquid # we execute the class decorator later after setting up all the bolt stuff
            class PotionLiquidClass:
                id = row["potion_id"].removeprefix("long_")
                name = "TODO NAME LOOKUP" # TODO

                _generators = []
            if row["potion_id"].startswith("strong"):
                PotionLiquidClass.skin = row["potion_id"].removeprefix("strong_")

            potion_liquid.struc = PotionLiquidClass # programatically going around the decorators is odd,
                                                    # so we manually set this here so the handler 
                                                    # knows the right classdef to put mcfunction into
            potion_liquid.init()

            class_defs[class_key] = PotionLiquidClass
        this_potion_class = class_defs[class_key]
        potion_liquid.struc = this_potion_class

        # add this potion to the liquid type
        if row["potion_id"].startswith("long"):
            this_potion_unit = long_potion
        else:
            this_potion_unit = base_potion
        this_potion_unit(f"minecraft:potion[potion_contents={{potion:\"{row['potion_id']}\"}}]")

        # add this potion's util_below feature
        if not row["potion_id"].startswith("long"):
            def dispense_potion(row):
                effects = row["effect_id"].split("+")
                amplifiers = map(int, row["effect_amplifier"].split("+"))
                inline_predicate = {
                    "condition":"minecraft:entity_properties",
                    "entity":"this",
                    "predicate":{
                        "effects":{}
                        # {   e:{} for e in effects  } # dict comprehension not supported by bolt
                    }
                }
                for e in effects:
                    inline_predicate["predicate"]["effects"][e] = {}

                m, s = row["effect_duration"].split(":")
                duration = int(m)*60 + round(float(s))
                execute as @e[team=!invalid_team,type=!armor_stand,tag=!smithed.strict,limit=1,dx=0]
                    unless entity @s[gamemode=spectator]
                    if predicate inline_predicate
                    run function f"gm4_potion_liquids:util/dispense/{row["potion_id"]}":
                        for e, a in zip(effects, amplifiers):
                            effect give @s e duration (a-1)
                        scoreboard players remove @e[type=marker,tag=gm4_liquid_tank,tag=gm4_processing_tank,distance=..8] gm4_lt_value 1
                        playsound entity.player.swim block @a[distance=..8] ~ ~ ~ .5 1.5
            potion_liquid.util_below(partial(dispense_potion, row))

# apply the liquid tanks decorator wrapper
for liquid_class in class_defs.values():
    potion_liquid(liquid_class)


# @potion_liquid
# class HealthPotion:
#     id = "healing"
#     name = "Healing"

#     potion_liquid.init()
#     bottle('minecraft:potion[potion_contents={potion:"healing"}]')
#     potion_liquid.item_drain('minecraft:potion[potion_contents={potion:"healing"}]', "bottle", 3)

#     @potion_liquid.util_below
#     def dispense_potion():
#         execute as @e[team=!invalid_team,type=!armor_stand,tag=!smithed.strict,limit=1,dx=0]
#             unless entity @s[gamemode=spectator]
#             if entity @s[nbt=!{active_effects:[{id:'minecraft:instant_health'}]}]
#             run function gm4_potion_liquids:util/healing:
#                 effect give @s night_vision 180 0
#                 scoreboard players remove @e[type=marker,tag=gm4_liquid_tank,tag=gm4_processing_tank,distance=..8] gm4_lt_value 1
#                 playsound entity.player.swim block @a[distance=..8] ~ ~ ~ .5 1.5

# print(ctx.data.function["gm4_potion_liquids:util_below"].text.splitlines())
