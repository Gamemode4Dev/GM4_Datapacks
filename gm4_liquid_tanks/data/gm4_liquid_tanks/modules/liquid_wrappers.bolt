from functools import wraps, partial

from beet import Context


# We're trying out a class-definition approach, rather than a class-instantiation one. 
    # it might wind up feeling more natural within bolt
def liquid(cls):
    print("defining new basic liquid")
    @wraps(cls)
    class ThisLiquid(cls):
        pass

    return ThisLiquid

# function that generates no mcfunction
def emptyfunc():
    pass

class Liquid:
    """Base class providing decorators and infrastructure for adding Liquid Tanks liquids"""
    id: str = None
    capacity: int = None
    skullowner: str = None
    _fields = ['id', 'capacity', 'skullowner']

    def __init__(self, *args, **kwargs):
        # create instance attributes (named defined by _fields) based on constructor
        input_args = dict(zip(self._fields, args)) | kwargs
        for field in self._fields:
            if v:=input_args.get(field, None):
                setattr(self, field, v)
        self.generators = [] # functions that create mcfunction using bolt

    def __call__(self, cls):
        """instance acts as decorator for defining new class-structures"""
        @wraps(cls, updated=())
        class DecoratedLiquid(cls, Liquid):
            pass

        # set unbound DecoratedLiquid class attributes
        for field in self._fields:
            if v:=getattr(self, field, None):
                setattr(DecoratedLiquid, field, v)

        print(self.generators)
        self.generators.clear()

        return DecoratedLiquid
    
    def init(self, fcn=emptyfunc):
        @wraps(fcn)
        def wrapped_fcn():
            # function tank_init/milk:
                # summon item_display ~ ~ ~
            fcn()
            pass

        # give nicer info about this wrapped function if not used as decorator
        wrapped_fcn.__qualname__ = "Liquid.init" if fcn is emptyfunc else fcn.__qualname__

        self.generators.append(wrapped_fcn)
        return wrapped_fcn
    

    def _default_item_fill(id:str):
        # data merge storage gm4_liquid_tanks:temp/tank {output:{id:"beetroot_soup"}}
        pass
    
    
    def item_fill(self, input: str, output: str, value: int, reversable: bool = True):
        def dec_with_args(fcn, fcn_to_replace):
            @wraps(fcn)
            def wrapped_fcn():
                # execute if item input run function output:
                    # scoreboard players set $item_value gm4_lt_value -1
                    # fcn()
                    # data merge storage gm4_liquid_tanks:temp/tank {output:{id:"beetroot_soup"}}
                    # function gm4_liquid_tanks:smart_item_fill
                    # tag @s add gm4_lt_fill
                pass

            # give nicer info about this wrapped function if not used as decorator
            wrapped_fcn.__qualname__ = "Liquid.item_fill" if isinstance(fcn, partial) else fcn.__qualname__

            if fcn_to_replace in self.generators:
                self.generators.remove(fcn_to_replace)
            self.generators.append(wrapped_fcn)
            return wrapped_fcn
        
        default_dec = dec_with_args(partial(self._default_item_fill, id=output), None)

        return_dec = partial(dec_with_args, fcn_to_replace=default_dec)
        return return_dec
    
liquid = Liquid() # common instance for most cases
    
if __name__ == "__main__":

    ## Defining a class

    # by decorated class
    @liquid
    class Milk:
        id = 'milk'
        capacity = 300
        skullowner = 'skins/milk'

    print(Milk.id)
    print(Milk.capacity)

    # or by extended base decorator with partial bindings
    bucketable = Liquid(None, 300, None)

    print(bucketable.id)
    print(bucketable.capacity)

    @bucketable
    class PowderSnow:
        id = 'powder_snow'
        capacity = 400
        skullowner = 'skins/snow'

    print(PowderSnow.capacity)

    ## Using methods to define behavior
    @liquid
    class MushroomSoup:
        id = 'mushroom_soup'
        capacity = 300
        skullowner = 'skins/snow'

        @liquid.init
        def liquid_init():
            # particle block ~ ~ ~ red_mushroom 1 0 force
            pass

    # or with no additional code
    @liquid
    class BeetrootSoup:
        id = 'beetroot_soup'
        capacity = 300
        skullowner = 'skins/beetboi'

        liquid_init = liquid.init()

    # or even programatically?
    @liquid
    class RabbitStew:
        id = 'rabbit_stew'
        capacity = 300
        skullowner = 'skins/bunnyface'

    # @RabbitStew.init # I don't know if this is desirable or useful yet, so I'll leave it here for the time being
    # def stew_init():
    #     # summon killer_bunny
    #     pass

    # using methods to define arbitrary item fills
    @liquid
    class Experience:
        id = 'xp'
        capacity = 1365
        skullowner = 'skins/magic'

        @liquid.item_fill('bottle', 'xp_bottle', 6)
        def experience_bottle():
            pass

        magic_book = liquid.item_fill('book', 'enchanted_book', 3)

        liquid.item_fill('paper', 'explorer_map', 100)

    # or defining common units for shared use using partial
    bottle = partial(liquid.item_fill, input='bottle', value=1)

    @liquid
    class Honey:
        id = 'honey',
        capacity = 400
        skullowner = 'skins/beesbeesallthebees'

        @bottle(output='honey_bottle')
        def honey_bottle():
            pass

        bottle(output='dragons_breath')


    # @standard_unit('bucket', 3)
    # def bucket():
    #     #summon bat{CustomName:'Whoops there goes your bucket'}
    #     pass

    # bottle = standard_unit('bottle', 1)
    # bottle = partial(liquid.item_fill, input='bottle', value=3)

    # @liquid
    # class Lava:
    #     id = 'lava'
    #     capacity = 100
    #     skullowner = 'skins/lava'

    #     @liquid_init
    #     def lava_init():
    #         #advancement grant @p gm4_standard_liquids:mini_volcano
    #         pass

    #     @item_fill('bucket', 'lava_bucket', 3, reversible=True)
    #     def lava_bucket():
    #         #advancement grant @p gm4_standard_liquids:shouldnt_that_iron_melt
    #         pass

    #     # reversible would automatically create the item_drain direction.
    #         # what about additional commands in that direction? Do I dare use yield and generators?
    #         # we generally assume anything that can be filled can also be drained, exceptions are usually for items destroyed by the drain
    #         # like enchanted pages, beetroot and honey_blocks.

    #     lava_bucket = item_drain('magma_block', 'air', 2, reversible=False)
    #         # maybe like this if there are no additional commands to run?

    #     @bottle('potion{gm4_standard_liquids:{id:"lava_bottle"}}') # acts as an `item_fill` decorator?
    #     def lava_bottle():
    #         #loot insert container.0 gm4_standard_liquids:lava_bottle
    #         pass

        # yea dealing with non-standard items is a real pain in the ass even with this system...
        

    # @Liquid()
    # class Test2:
    #     def my_2method(self):
    #         print("my_2method")

    # print(Lava)


# "overloading" the decorator in this way seems... difficult to say the least. Maybe rx has some thoughts about how to do this better
    # I *think* that it can be acomplished, but it would require like... delaying the mcfunction creation until we're sure the decorator isn't 
    # going to be called to wrap a method. Is there like an exit phase? Or maybe at the end of the @liquid class wrapper we can run through all
    # its liquid processors?
