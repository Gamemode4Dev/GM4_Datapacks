from functools import wraps, partial

from beet import Context
from mecha import Mecha, AstItemStack

from gm4.utils import add_namespace

from gm4_auto_crafting.generate import unstackables, stackable_16 # NOTE future versions can pull the default component from 1.20.5 item.json


# We're trying out a class-definition approach, rather than a class-instantiation one. 
    # it might wind up feeling more natural within bolt
def liquid(cls):
    print("defining new basic liquid")
    @wraps(cls)
    class ThisLiquid(cls):
        pass

    return ThisLiquid

# function that generates no mcfunction
def emptyfunc():
    pass

class Liquid:
    """Base class providing decorators and infrastructure for adding Liquid Tanks liquids"""
    id: str = None
    capacity: int = None
    name: str = None
    _fields = ['id', 'capacity', 'name']


    def __init__(self, *args, **kwargs):
        # create instance attributes (named defined by _fields) based on constructor
        input_args = dict(zip(self._fields, args)) | kwargs
        for field in self._fields:
            if input_args.get(field, None):
                setattr(self, field, input_args.get(field, None))
        self.generators = [] # functions that create mcfunction using bolt
        self.units = {} # reusable quantities shared amongst liquids
        self.struc = Liquid
        self.mc = ctx.inject(Mecha)

    def __call__(self, cls):
        """instance acts as decorator for defining new class-structures"""
        @wraps(cls, updated=())
        class DecoratedLiquid(cls, Liquid):
            pass

        # set unbound DecoratedLiquid class attributes
        for field in self._fields:
            if getattr(self, field, None):
                setattr(DecoratedLiquid, field, getattr(self, field, None))

        print(self.generators)
        self.struc = DecoratedLiquid # link access to class variables through `self`
        for fcn in self.generators:
            fcn() # create the mcfunction resources
        self.generators.clear()

        return DecoratedLiquid
    
    def init(self, fcn=emptyfunc):
        @wraps(fcn)
        def wrapped_fcn():
            function ~/../liquid_init/{self.struc.id}:
                # append function_tag gm4_liquid_tanks:tank_init {"values": [(~/)]} # FIXME this line is for... what?
                data merge block ~ ~ ~ {CustomName:f'{{"translate":"gm4.second","fallback":"%1$s","with":[{{"translate":"container.gm4.liquid_tank.{self.struc.id}","fallback":"{self.struc.name} Tank"}},[{{"translate":"gui.gm4.liquid_tank","fallback":"","font":"gm4:container_gui","color":"white"}},{{"translate":"container.gm4.liquid_tank.{self.struc.id}","fallback":"{self.struc.name} Tank","font":"gm4:default","color":"#404040"}}]]}}'}
                summon armor_stand ~ ~-.95 ~:
                    CustomName: '"gm4_liquid_tank_display"'
                    Tags: ["gm4_no_edit","gm4_liquid_tank_display","smithed.entity","smithed.strict"]
                    NoGravity: 1
                    Marker: 1
                    Invisible: 1
                    Invulnerable: 1
                    Small: 1
                    Silent: 1
                    DisabledSlots:4144959
                    HasVisualFire: 1
                    ArmorItems:[{},{},{},{id:"player_head",Count:1b,tag:{SkullOwner:"$gm4_standard_liquids:liquids/lava"}}]
                data modify entity @s data.gm4_liquid_tanks.liquid_tag set value f"gm4_lt_{self.struc.id}"
                scoreboard players set @s gm4_lt_max self.struc.capacity
                tag @s add f'gm4_lt_{self.struc.id}'
                tag @s remove gm4_lt_empty
                fcn()
            
            append function ~/../remove_liquid_tags:
                append function_tag gm4_liquid_tanks:remove_liquid_tags {"values": [(~/)]}
                tag @s remove f'gm4_lt_{self.struc.id}'
            pass

        # give nicer info about this wrapped function if not used as decorator
        if fcn:
            wrapped_fcn.__qualname__ = "Liquid.init"
        else:
             wrapped_fcn.__qualname__ = fcn.__qualname__

        self.generators.append(wrapped_fcn)
        return wrapped_fcn
    
    @staticmethod
    def _default_set_output(id:str):
        data merge storage gm4_liquid_tanks:temp/tank {output:{id:id}}
        pass
    
    
    def item_fill(self, input: str, output: str, value: int, reversable: bool = True, ignore_standard_units: bool = False):
        def dec_with_args(fcn, fcn_to_replace):
            @wraps(fcn)
            def wrapped_fcn():
                # item = self.mc.parse(output, type=AstItemStack) # FIXME no parser asscioated?
                output_ast = self.mc.parse(output, using='item_stack')
                output_id = self.mc.serialize(output_ast.identifier).removeprefix('minecraft:')
                print(f"\tItem Fill {input}->{output_id}")
                ns_output = add_namespace(output_id, "minecraft")
                if ns_output in unstackables:
                    stack_limit = "1"
                elif ns_output in stackable_16:
                    stack_limit = "..16"
                else:
                    stack_limit = "..64" # FIXME this should remove that execute subcommand from the chain.. somehow

                append function ~/../item_fill:
                    execute if entity @s[tag=f'gm4_lt_{self.struc.id}'] if score $stack_size gm4_lt_value matches stack_limit if data storage gm4_liquid_tanks:temp/tank {input_slot:{id:add_namespace(input, "minecraft")}} run function ~/{output_id}:
                        scoreboard players set $item_value gm4_lt_value value
                        fcn()
                        function gm4_liquid_tanks:smart_item_fill
                        tag @s add gm4_lt_fill

            # give nicer info about this wrapped function if not used as decorator
            if isinstance(fcn, partial):
                wrapped_fcn.__qualname__ = "Liquid.item_fill" 
            else:
                wrapped_fcn.__qualname__ = fcn.__qualname__

            if fcn_to_replace in self.generators:
                self.generators.remove(fcn_to_replace)
            self.generators.append(wrapped_fcn)
            return wrapped_fcn
        
        # create reverse
        if reversable:
            self.item_drain(output, input, -value)
        
        default_dec = dec_with_args(partial(self._default_set_output, id=output), None)

        return_dec = partial(dec_with_args, fcn_to_replace=default_dec)
        return return_dec
    
    def standard_unit(self, item: str, value: int, f_name: str = None):
        if not f_name: # mcfunction name
            f_name = item
        self.units.update({(item, value): f_name})
        # let unit act as an 'item_fill' decorator with input already set
        def dispatch(output: str):
            return partial(self.item_fill, input=item, value=value)(output=output)
        return dispatch
    

    def item_drain(self, input: str, output: str, value: int):
        def dec_with_args(fcn, fcn_to_replace):
            @wraps(fcn)
            def wrapped_fcn():
                print(f"\tItem Drain {input}->{output}")
                # if isinstance(fcn, partial) and fcn.func is self._default_set_output: # there aren't extra commands to consider
                f_name = self.units.get((output, -value), input)
                # f_name = input
                print(f"reusing {f_name}")

                append function ~/../item_drain:
                    execute if entity @s[tag=f'gm4_lt_{self.struc.id}'] if data storage gm4_liquid_tanks:temp/tank {input_slot:{id:add_namespace(input, "minecraft")}} run function f'{~/}/{f_name}':
                        scoreboard players set $item_value gm4_lt_value value
                        fcn()
                        function gm4_liquid_tanks:smart_item_drain
                        tag @s add gm4_lt_fill
                
                append function ~/../tank_init:
                    execute if data storage gm4_liquid_tanks:temp/tank {input_slot:{id:add_namespace(input, "minecraft")}} run function ~/../liquid_init/{self.struc.id}
                pass

            # give nicer info about this wrapped function if not used as decorator
            if isinstance(fcn, partial):
                wrapped_fcn.__qualname__ = "Liquid.item_fill" 
            else:
                wrapped_fcn.__qualname__ = fcn.__qualname__

            if fcn_to_replace in self.generators:
                self.generators.remove(fcn_to_replace)
            self.generators.append(wrapped_fcn)
            return wrapped_fcn
        
        default_dec = dec_with_args(partial(self._default_set_output, id=output), None)

        return_dec = partial(dec_with_args, fcn_to_replace=default_dec)
        return return_dec
    
    
    
liquid = Liquid() # common instance for most cases
    
if __name__ == "__main__":

    ## Defining a class

    # by decorated class
    @liquid
    class Milk:
        id = 'milk'
        capacity = 300
        skullowner = 'skins/milk'

    print(Milk.id)
    print(Milk.capacity)

    # or by extended base decorator with partial bindings
    bucketable = Liquid(None, 300, None)

    print(bucketable.id)
    print(bucketable.capacity)

    @bucketable
    class PowderSnow:
        id = 'powder_snow'
        capacity = 400
        skullowner = 'skins/snow'

    print(PowderSnow.capacity)

    ## Using methods to define behavior
    @liquid
    class MushroomSoup:
        id = 'mushroom_soup'
        capacity = 300
        skullowner = 'skins/snow'

        @liquid.init
        def liquid_init():
            # particle block ~ ~ ~ red_mushroom 1 0 force
            pass

    # or with no additional code
    @liquid
    class BeetrootSoup:
        id = 'beetroot_soup'
        capacity = 300
        skullowner = 'skins/beetboi'

        liquid_init = liquid.init()

    # or even programatically?
    @liquid
    class RabbitStew:
        id = 'rabbit_stew'
        capacity = 300
        skullowner = 'skins/bunnyface'

    # @RabbitStew.init # I don't know if this is desirable or useful yet, so I'll leave it here for the time being
    # def stew_init():
    #     # summon killer_bunny
    #     pass

    # using methods to define arbitrary item fills
    @liquid
    class Experience:
        id = 'xp'
        capacity = 1365
        skullowner = 'skins/magic'

        @liquid.item_fill('bottle', 'xp_bottle', 6)
        def experience_bottle():
            pass

        magic_book = liquid.item_fill('book', 'enchanted_book', 3, False)

        liquid.item_fill('paper', 'explorer_map', 100, False)

    # or defining common units for shared use using partial
    bottle = partial(liquid.item_fill, input='bottle', value=1)

    @liquid
    class Honey:
        id = 'honey'
        capacity = 400
        skullowner = 'skins/beesbeesallthebees'

        @bottle(output='honey_bottle')
        def honey_bottle():
            pass

        bottle(output='dragons_breath')

        @liquid.item_drain(input='honey_block', output='air', value=4)
        def honey_block():
            pass


    # @standard_unit('bucket', 3)
    # def bucket():
    #     #summon bat{CustomName:'Whoops there goes your bucket'}
    #     pass

    # bottle = standard_unit('bottle', 1)
    # bottle = partial(liquid.item_fill, input='bottle', value=3)

    # @liquid
    # class Lava:
    #     id = 'lava'
    #     capacity = 100
    #     skullowner = 'skins/lava'

    #     @liquid_init
    #     def lava_init():
    #         #advancement grant @p gm4_standard_liquids:mini_volcano
    #         pass

    #     @item_fill('bucket', 'lava_bucket', 3, reversible=True)
    #     def lava_bucket():
    #         #advancement grant @p gm4_standard_liquids:shouldnt_that_iron_melt
    #         pass

    #     # reversible would automatically create the item_drain direction.
    #         # what about additional commands in that direction? Do I dare use yield and generators?
    #         # we generally assume anything that can be filled can also be drained, exceptions are usually for items destroyed by the drain
    #         # like enchanted pages, beetroot and honey_blocks.

    #     lava_bucket = item_drain('magma_block', 'air', 2, reversible=False)
    #         # maybe like this if there are no additional commands to run?

    #     @bottle('potion{gm4_standard_liquids:{id:"lava_bottle"}}') # acts as an `item_fill` decorator?
    #     def lava_bottle():
    #         #loot insert container.0 gm4_standard_liquids:lava_bottle
    #         pass

        # yea dealing with non-standard items is a real pain in the ass even with this system...
        

    # @Liquid()
    # class Test2:
    #     def my_2method(self):
    #         print("my_2method")

    # print(Lava)


# "overloading" the decorator in this way seems... difficult to say the least. Maybe rx has some thoughts about how to do this better
    # I *think* that it can be acomplished, but it would require like... delaying the mcfunction creation until we're sure the decorator isn't 
    # going to be called to wrap a method. Is there like an exit phase? Or maybe at the end of the @liquid class wrapper we can run through all
    # its liquid processors?
