from beet import Context, subproject, Cache, Language, Function
from pathlib import Path
from typing import Any
from gm4.utils import CSV
from gm4.plugins.resource_pack import ContainerGuiOptions, GuiFont

def beet_default(ctx: Context):

    trades_init: list[str] = []
    trades_list: list[str] = []
    trades_append: list[str] = []
    
    furniture_sets: dict[str,CSV] = {}

    for path in sorted(Path('gm4_furniture/raw_data/furniture_set').glob('*.csv')):
        furniture_sets[path.stem] = CSV.from_file(path)

    # loop through the different sheets, each sheet hold a different 'set_name'
    # of furniture which need to be sorted in the furniture_station storage
    for set_name, furniture_set in furniture_sets.items():

        # call generate_trade_data to build the commands
        new_trades_init,new_trades_list,new_trades_append = generate_trade_data(ctx, furniture_set, set_name)
        # append the trade data to the total list
        trades_init.append(new_trades_init)
        trades_list += new_trades_list
        trades_append.append(new_trades_append)

        # read furniture data from this sheet, and then create the placement function
        # and loot table for each furniture
        generate_furniture_data(ctx, furniture_set, set_name)

    # generate trades function
    function_strings: list[str] = [
        "# create storage to hold the trade data for furniture items in furniture station",
        "# @s = unspecified",
        "# at unspecified",
        "# run from init",
        "# generated by generate.py\n"
    ]
    for string in trades_init + trades_list + trades_append:
        function_strings.append(string)
    function_strings.append("\ndata remove storage gm4_furniture:temp new_trades")
    ctx.data.functions['gm4_furniture:generate_trades'] = Function(function_strings)

def generate_trade_data(ctx: Context, furniture_set: CSV, set_name: str):

    # create a command to make an empty storage called new_trades that holds the set_name name and tool cmd
    new_trades_init = "data modify storage gm4_furniture:temp new_trades." + set_name + " set value {\"minecraft:item_model\":\"gm4_furniture:set_tool/" + set_name + "\",trades:[]}"

    # iterate over the rows in the spreadsheet and add the trade data for each furniture to the storage
    new_trades_list: list[str] = []
    for row in furniture_set:
        new_trades_list.append("data modify storage gm4_furniture:temp new_trades." + set_name + ".trades append value {cost:[{id:" + row['craft_item_1_id'] + ",count:" + row['craft_item_1_count'] + "b},{id:" + row['craft_item_2_id'] + ",count:" + row['craft_item_2_count'] + "b}],result:{furniture_id:\"" + set_name + "/" + row['technical_id'] + "\",count:" + row['craft_result_count'] + "}}")

    # add command to append the main furniture_station storage with the newly created new_trades
    new_trades_append = "data modify storage gm4_furniture:data furniture_station prepend from storage gm4_furniture:temp new_trades." + set_name

    # return the created commands
    return(new_trades_init,new_trades_list,new_trades_append)

def generate_furniture_data(ctx: Context, furniture_set: CSV, set_name: str):

    # create furniture loot tables and placement functions for every furniture in this category
    for row in furniture_set:

        # set item model
        item_model = "gm4_furniture:" + set_name + "/" + row['technical_id'].replace(".","/")

        # build placement function and loot table for furniture piece
        subproject_config = {
            "data_pack": {
                "load": [
                    {
                        f"data/gm4_furniture/loot_table/furniture/{set_name}/{row['technical_id']}.json": "data/gm4_furniture/template/loot_table/furniture_item_template.json",
                        f"data/gm4_furniture/function/place/furniture/{set_name}/{row['technical_id']}.mcfunction": "data/gm4_furniture/template/function/furniture_place_template.mcfunction",
                    }
                ],
                "render": {
                    "loot_table": "*",
                    "function": "*"
                }
            },
            "meta": {
                "category": set_name,
                "technical_id": row['technical_id'],
                "display_name": row['display_name'],
                "item_model": item_model,
                "block_id": row['block_id'],
                "sittable": row['sittable'],
                "wall_only": str(int(row['wall_only'] == 'TRUE')),
                "ceiling_only": str(int(row['ceiling_only'] == 'TRUE')),
                "dyeable": str(int(row['dyeable'] == 'TRUE')),
                "length": row['length'],
                "depth": row['depth'],
                "height": row['height'],
                "table": str(int(row['table'] == 'TRUE')),
                "scale": row['scale'],
                "allow_diagonal_placement": str(int(row['diag'] == 'TRUE')),
                "custom_interaction": str(int(row['custom_interaction'] == 'TRUE')),
                "custom_placement" : str(int(row['custom_placement'] == 'TRUE'))
            }
        }

        ctx.require(subproject(subproject_config))
        
        ctx.generate("gm4_translations:en_us", merge=Language({
            f"block.gm4_furniture.{ set_name }.{ row['technical_id'] }": row['display_name']
        }))

class FurnitureStationGui(ContainerGuiOptions):
    container = "furniture_station"

    def process(self, config: GuiFont, counter_cache: Cache) -> tuple[str, list[dict[str, Any]]]:
        u1 = self.next_unicode(counter_cache)
        u2 = self.next_unicode(counter_cache)
        return "\u8020"+u1+"\u8100"+u2+"\u8021", [
            {
                "type": "bitmap",
                "file": config.texture+"_1.png",
                "ascent": 20,
                "height": 256,
                "chars": [u1]
            },
            {
                "type": "bitmap",
                "file": config.texture+"_2.png",
                "ascent": 20,
                "height": 256,
                "chars": [u2]
            }
        ]
